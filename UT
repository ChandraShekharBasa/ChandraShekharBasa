const express = require('express');
const router = express.Router();
const { checkSchema, validationResult } = require('express-validator');
const kvClient = require('../utils/keyVault');
const axios = require('axios');
const logger = require('../utils/logger');
const httpsAgent = require('../utils/httpsAgent');
const { XMCCORRELATIONID, CDM_CREATE_CONSENT_ENDPOINT } = require('../utils/constants');
const { isFeatureFlagEnabled } = require('../utils/featureFlagService');

const Netstorage = require('../utils/netstorage/netstorage');

const url = process.env.VITE_VCITA_API;

const checkboxValidator = (value) => !!value;

router.post(
	'/register',
	checkSchema(
		{
			email: {
				trim: true,
				notEmpty: {
					errorMessage: 'EMAIL_REQUIRED',
				},
				isEmail: {
					errorMessage: 'ENTER_VALID_EMAIL',
				},
			},
			businessname: {
				trim: true,
				notEmpty: {
					errorMessage: 'BUSINESS_NAME_REQUIRED',
				},
			},
			password: {
				trim: true,
				notEmpty: {
					errorMessage: 'PASSWORD_REQUIRED',
				},
				isLength: {
					options: { min: 8 },
					errorMessage: 'PASSWORD_MIN_CHARS_8',
				},
				custom: {
					options: (value) => {
						return (
							/[ !@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/g.test(value) && /[A-Z]/g.test(value) && /[0-9]/g.test(value)
						);
					},
					errorMessage: 'PASSWORD_CRITERIA_ERROR',
				},
			},
			repassword: {
				notEmpty: {
					errorMessage: 'REPASS_REQUIRED',
				},
				custom: {
					options: (value, { req }) => value === req.body.password,
					errorMessage: 'REPASS_NOT_SAMEAS_PASS',
				},
			},
			iAgreeCheck: {
				custom: {
					options: checkboxValidator,
					errorMessage: 'TNC_ACCEPT_ERROR',
				},
			},
			hippaCheckbox: {
				custom: {
					options: checkboxValidator,
					errorMessage: 'HIPPA_ACCEPT_ERROR',
				},
			},
		},
		['body'],
	),
	async (req, res) => {
		const errors = validationResult
			.withDefaults({
				formatter: (error) => ({
					key: error.path,
					msg: req.constants ? req.constants[error.msg] || error.msg : error.msg,
				}),
			})(req)
			.array({ onlyFirstError: true });
		if (errors.length) {
			return res.status(400).json({ errors });
		}

		const distributorCode = req.headers.distributor;
		const correlationId = req.headers[XMCCORRELATIONID];
		let token;
		try {
			const { value } = await kvClient().getSecret('VCITA-AUTH-' + distributorCode.toUpperCase());
			token = value;
		} catch (error) {
			logger.info(`Failed getting ${distributorCode} vcita token from key vault`, {
				httpmethod: 'POST',
				url: url + '/businesses',
				responsecode: 500,
				correlationid: correlationId,
				operation: 'Vcita account creation',
				suboperation: 'API Request',
				remoteip: req.headers['x-forwarded-for'] || req.headers['True-Client-Ip'],
				error: error,
			});

			return res.status(500).json({
				title: req.constants?.OOPS_ERROR,
				message: req.constants?.SOMETHING_WRONG,
			});
		}
		const maskedMail = req.body.email.replace(/(?<=.).(?=[^@]*?.@)/g, 'x');
		let maskedBody = {};

		const headers = {
			Accept: 'application/json',
			Authorization: `Bearer ${token}`,
			[XMCCORRELATIONID]: correlationId,
		};

		const body = {
			admin_account: {
				email: req.body.email,
				password: req.body.password,
				language: req.body?.languageCode,
			},
			business: {
				name: req.body.businessname,
			},
			meta: {
				external_reference_id: req.body.uniqueExternalIdentifier || req.body.email,
			},
		};

		maskedBody = JSON.parse(JSON.stringify(body));
		maskedBody.admin_account.email = maskedMail;
		maskedBody.meta.external_reference_id =
			maskedBody.meta?.external_reference_id?.replace(/(?<=.).(?=[^@]*?.@)/g, 'x') || '';
		delete maskedBody.admin_account.password;

		logger.info(`Create account on vcita with email -> ${maskedMail}`, {
			url: url + '/businesses',
			httpmethod: 'POST',
			body: maskedBody,
			correlationid: correlationId,
			operation: 'Vcita account creation',
			suboperation: 'API Request',
			remoteip: req.headers['x-forwarded-for'] || req.headers['True-Client-Ip'],
		});

		const startTime = new Date().getTime();

		try {
			// if the user is in the test list, don't call vcita
			let response = {};
			if (req.body.email == 'successfulRegistrationTest@mastercard.com') {
				response.data = {
					data: {
						title: 'Successful Registration',
						message: 'This is a mock response.',
					},
				};
			} else {
				response = await axios.post(url + '/businesses', body, { headers, httpsAgent: httpsAgent() });
			}

			const endTime = new Date().getTime();
			const responseTime = endTime - startTime;
			const responseData = response.data;
			const maskedRespData = JSON.parse(JSON.stringify(responseData.data));

			delete maskedRespData.business.admin_account.email;
			delete maskedRespData.business.admin_account.phone;
			delete maskedRespData.business.business.phone;

			logger.info(`Successfully created account on vcita with email -> ${maskedMail}`, {
				url: url + '/businesses',
				httpmethod: 'POST',
				responsecode: 200,
				body: maskedBody,
				data: maskedRespData,
				correlationid: correlationId,
				operation: 'Vcita account creation',
				suboperation: 'API Response',
				remoteip: req.headers['x-forwarded-for'] || req.headers['True-Client-Ip'],
				responseTime: responseTime + 'ms',
			});
			res.json(responseData);
		} catch (error) {
			const endTime = new Date().getTime();
			const responseTime = endTime - startTime;

			const responseCode = error?.response?.status || 500;

			logger.error(`BACK-03-${responseCode}-011: Error calling create account API on Vcita`, {
				url: url + '/businesses',
				body: maskedBody,
				httpmethod: 'POST',
				responsecode: responseCode,
				error: error?.response?.data,
				correlationid: correlationId,
				operation: 'Vcita account creation',
				suboperation: 'API Response',
				remoteip: req.headers['x-forwarded-for'] || req.headers['True-Client-Ip'],
				responseTime: responseTime + 'ms',
				errorCode: `BACK-03-${responseCode}-011`,
			});
			res.status(responseCode).json({ error: error?.response?.data?.message || req.constants?.INTERNAL_SERVER_ERROR });
		}
	},
);
